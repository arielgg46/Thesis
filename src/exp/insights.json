{
    "agent": {
        "domain": {
            "blocksworld": {
                "rules": [
                    [
                        "When defining a blocksworld problem, all blocks must be initialized with their clear status and position (on table or on another block) explicitly stated, ensuring consistency with the domain's predicates and avoiding conflicting conditions.",
                        6
                    ],
                    [
                        "The goal state must specify the arm's status (empty) and the clear status and position of all relevant blocks, even if they remain unchanged from the initial state.",
                        6
                    ]
                ],
                "world_knowledge": [
                    [
                        "In the blocksworld domain, blocks can only be stacked directly on top of one another, with a single block or the table as the base.",
                        6
                    ],
                    [
                        "The arm can only hold one block at a time, requiring blocks to be picked up and put down in sequence.",
                        6
                    ]
                ]
            },
            "gripper": {
                "rules": [
                    [
                        "When grippers are explicitly described as carrying objects in the initial state, ensure the initial state reflects this by including (carry ?obj ?gripper) predicates and excluding (free ?gripper) predicates.",
                        3
                    ],
                    [
                        "When all grippers are occupied in the initial state, ensure the (free ?gripper) predicate is negated for each gripper to accurately represent their unavailability.",
                        3
                    ],
                    [
                        "When the goal involves grippers carrying specific objects, ensure the goal state includes (carry ?obj ?gripper) predicates for each pair, even if the initial state already satisfies the goal.",
                        3
                    ],
                    [
                        "If the robot\u2019s location is not explicitly stated in the problem description, default to treating it as being in the only available room.",
                        2
                    ],
                    [
                        "When defining the goal state for object distribution across rooms, ensure that the specific objects assigned to each room are explicitly stated, even if the problem description only specifies counts, to avoid ambiguity in the solution.",
                        2
                    ],
                    [
                        "If the robot's initial location is specified but not all balls or objects are in that room, ensure the goal state accounts for the robot\u2019s movement across rooms to complete the task.",
                        2
                    ],
                    [
                        "When the goal involves changing the location of multiple objects, ensure each object\u2019s initial and goal locations are explicitly defined to avoid ambiguity and ensure the planner can find a valid path.",
                        2
                    ],
                    [
                        "If the robot\u2019s initial location is not specified, it is reasonable to default its starting position to the room containing the most objects, as it likely requires the most interaction.",
                        2
                    ]
                ],
                "world_knowledge": []
            },
            "floor-tile": {
                "rules": [
                    [
                        "When the problem involves painting tiles with a uniform color, ensure the goal state explicitly lists each tile with the desired color, even if the robot already holds that color, to avoid ambiguity and ensure completeness.",
                        2
                    ],
                    [
                        "In problems where the goal involves painting tiles with different colors, the goal state should specify the exact color for each tile to ensure the distinct color constraints are met.",
                        2
                    ],
                    [
                        "When the goal involves painting each tile with a unique color, ensure the goal state includes constraints to enforce that no color is used more than once, even if the problem description does not explicitly specify the assignments.",
                        2
                    ],
                    [
                        "In problems where robots are distributed across different grid locations, consider their initial positions and colors as key factors in optimizing the sequence of painting actions.",
                        2
                    ],
                    [
                        "When multiple robots are available and distributed across the grid, consider their initial positions and color assignments to optimize the sequence of painting actions, minimizing redundant movements and color changes.",
                        2
                    ],
                    [
                        "In problems where the goal requires uniform painting of all tiles, ensure that the color constraints in the goal state align with the robots' initial colors to avoid unnecessary color changes.",
                        2
                    ]
                ],
                "world_knowledge": [
                    [
                        "In grid-based painting domains, robots must navigate both horizontal and vertical relationships to access all tiles, making bidirectional spatial relationships essential for achieving the goal.",
                        2
                    ],
                    [
                        "In grid-based painting domains, bidirectional spatial relationships (e.g., right and left, up and down) are essential for enabling full navigability and ensuring robots can access all tiles.",
                        2
                    ]
                ]
            }
        },
        "general": {
            "rules": [
                [
                    "Goals should be defined in a way that ensures all necessary conditions are met, including those that may seem implied but are explicitly required by the domain's predicates.",
                    10
                ],
                [
                    "Problem descriptions should explicitly mention the initial state of all objects and the agent (e.g., arm-empty), even if they are not directly involved in the goal.",
                    9
                ],
                [
                    "When the problem description specifies a distribution of objects across locations, the goal state must explicitly define the location of each object to ensure the distribution constraints are met.",
                    8
                ],
                [
                    "Assumptions about unspecified goal states should be clearly reasoned and justified to ensure they align with the problem's requirements and domain constraints, particularly when defining object distributions.",
                    8
                ],
                [
                    "When the problem involves distributing objects across multiple locations, the goal state should specify the exact location of each object to ensure the distribution is accurately represented.",
                    2
                ],
                [
                    "When defining goals involving object distribution, ensure that the goal state explicitly accounts for the movement or rearrangement of objects, even if the initial state already partially satisfies the goal.",
                    2
                ],
                [
                    "When defining the initial state, ensure all objects and their properties (e.g., location, availability) are explicitly stated, even if some are not directly involved in the goal, to maintain consistency.",
                    2
                ],
                [
                    "When the problem involves redistributing objects across multiple locations, the goal state should explicitly account for the movement of each object, even if many objects remain in their initial locations.",
                    2
                ],
                [
                    "When dealing with grid-based domains, explicitly define the spatial relationships between tiles (e.g., right, up) in both directions to ensure complete navigability for robots.",
                    2
                ],
                [
                    "In domains involving painting or coloring, ensure that all possible color states (available, held by robot, applied to tiles) are properly initialized and accounted for in the goal.",
                    2
                ],
                [
                    "When defining a grid structure, ensure that the relationships between tiles are modeled consistently in both directions (e.g., both `(right tileA tileB)` and `(left tileB tileA)` if applicable), even if only one direction is used in the problem description.",
                    2
                ],
                [
                    "When the goal involves applying a uniform property (e.g., painting all tiles with the same color), explicitly list each instance in the goal state to avoid ambiguity, even if it seems redundant.",
                    2
                ],
                [
                    "When defining spatial relationships in grid-based domains, ensure that both row and column relationships are fully specified to enable complete navigability, even if the problem description only mentions one direction.",
                    2
                ],
                [
                    "In painting domains, when the robot's initial color aligns with the goal color, ensure the goal explicitly uses that color to avoid unnecessary color changes, unless the problem specifies otherwise.",
                    2
                ],
                [
                    "When a problem involves a uniform goal (e.g., painting all tiles the same color), ensure the goal state explicitly lists each instance to avoid ambiguity, even if it seems redundant, as this enforces a clear and complete representation.",
                    2
                ],
                [
                    "When the goal involves distributing properties (e.g., colors) across objects (e.g., tiles), ensure the goal state explicitly defines the property for each object to enforce the specific distribution constraints.",
                    2
                ],
                [
                    "When the problem involves unique assignments (e.g., painting each tile with a distinct color), ensure the goal state specifies the exact assignments to avoid ambiguity, even if the problem description leaves them open-ended.",
                    2
                ],
                [
                    "When modeling grid-based domains, ensure the initial state fully defines the grid structure, including all row and column relationships, to enable efficient robot navigation and planning.",
                    2
                ],
                [
                    "When multiple agents (e.g., robots) are involved, explicitly model their initial states and capabilities to enable efficient task allocation and parallel execution.",
                    2
                ],
                [
                    "In grid-based domains with uniform goals, ensure the goal state explicitly states the desired property for each object, even if the same property is applied to all objects, to maintain clarity and completeness.",
                    2
                ]
            ]
        }
    },
    "human": {
        "domain": {
            "blocksworld": {
                "rules": [
                    [
                        "I have to ALWAYS SPECIFY the state of each block (it's top and bottom) and of the arm (empty or holding a block)",
                        100
                    ],
                    [
                        "In my reasoning, both in the init and goal state, I MUST ALWAYS define the towers/stacks of blocks as bracketed lists of objects, e.g. [b1, b2, ..., bN] represents a stack, with the first element (b1) on the table, subsequent elements stacked on top of the previous one, and the last element (bN) clear"
                    ],
                    [
                        "In the PDDL I have to ALWAYS define the blocks states by each stack/tower they form, like a sequence of predicates ALWAYS of the form (clear bA) (on bA bB) (on bB bC) ... (on bY bZ) (on-table bZ) is a tower of blocks bA through bZ with the first on top and the last on the bottom of the tower",
                        100
                    ]
                ],
                "world_knowledge": [
                    [
                        "(clear bX) means that block bX has it's top clear, no other block is on top of it",
                        100
                    ],
                    [
                        "(on-table bX) means that block bX is directly laying on the table",
                        100
                    ],
                    [
                        "(arm-empty) means that the arm is empty, it is not holding any block",
                        100
                    ],
                    [
                        "(holding bX) means that the arm is holding block bX, it is not empty",
                        100
                    ],
                    [
                        "(on bX bY) means block bX is on top of block bY",
                        100
                    ],
                    [
                        "(on bX bX) is invalid: no block can be on top of itself",
                        100
                    ],
                    [
                        "A block can only be on the table or on top of another, and in the later case it doesn't count as being on the table",
                        100
                    ],
                    [
                        "A block can only be clear or have another block directly on top of it, it cannot have more than one block directly on top of it",
                        100
                    ],
                    [
                        "The arm can only be empty or holding exactly one block, it cannot be holding more than one block",
                        100
                    ],
                    [
                        "The only objects are the blocks. The table and the arm are not objects",
                        100
                    ]
                ]
            },
            "gripper": {
                "rules": [
                    [
                        "I MUST EXPLICITELY define in the init state the rooms, balls and grippers with predicates (room R), (ball B) and (gripper G)",
                        100
                    ],
                    [
                        "I have to ALWAYS SPECIFY the state of each ball (it is either held by a gripper, or it is at some room) and each gripper (free or holding one ball). In the init state this is MANDATORY for each object, and in the goal state ONLY the ones needed to guarantee the stated goal conditions",
                        100
                    ],
                    [
                        "In my reasoning I SHOULD first explicitely define the balls in every room with a bracketed list of balls for each room, and the state of each gripper by pairs of (gripper, state) where state is either 'free' or the ball it holds"
                    ]
                ],
                "world_knowledge": [
                    [
                        "The only objects are the rooms, the balls and the grippers, and have to be explicitely defined with predicates (room R), (ball B) and (gripper G) respectively, in the :init section",
                        100
                    ],
                    [
                        "(at-robby roomX) means that the robby is at roomX",
                        100
                    ],
                    [
                        "(at ballX roomY) means that ballX is at roomY",
                        100
                    ],
                    [
                        "(carry ballX gripperY) means that gripperY is carrying ballX",
                        100
                    ],
                    [
                        "(free gripperX) means that gripperX is free",
                        100
                    ],
                    [
                        "The robby is only one and it must be at exactly one room",
                        100
                    ],
                    [
                        "A ball can only be at exactly one room, or being carried by a gripper (in which case the \"carry\" predicate is used, and not the \"at\")",
                        100
                    ],
                    [
                        "A gripper can only be free, or holding exactly one ball, it cannot hold more than one ball",
                        100
                    ]
                ]
            },
            "floor-tile": {
                "rules": [
                    [
                        "In my reasoning, both of the initial and the goal state, I MUST ALWAYS define the grid as line-separated bracketed lists of tuples (tileX, coloring) to represent each row, from top to bottom, where coloring is either 'unpainted' or some 'colorY'", 
                        100
                    ],
                    [
                        "I MUST understand the rows as tiles distributed horizontally (hence using 'right' predicates to define them internally), and the columns as tiles distributed vertically (hence using 'up' predicates to define them internally)",
                        100
                    ]
                ],
                "world_knowledge": [
                    [
                        "(robot-at robotX tileY) means that the robotX is at the tileY",
                        100
                    ],
                    [
                        "(robot-has robotX colorY) means that the robotX has the colorY",
                        100
                    ],
                    [
                        "(right tileR tileL) means that tileR is adjacent and to the right of tileL, in the same row",
                        100
                    ],
                    [
                        "(up tileU tileD) means that tileU is adjacent and on top of tileD, in the same column",
                        100
                    ],
                    [
                        "(painted tileX colorY) means that tileX is painted/colored with colorY",
                        100
                    ],
                    [
                        "(available-color colorX) means that colorX is available",
                        100
                    ],
                    [
                        "A tile can only have at most one tile adjacent to it's right and at most one adjacent on top",
                        100
                    ],
                    [
                        "The only objects are the robots, the tiles and the colors",
                        100
                    ],
                    [
                        "A robot must be at exactly one tile",
                        100
                    ],
                    [
                        "Unless the rows are disconnected, the first row is up and the second row is down (the first is on top of the second), the second is on top of the third, and so on.",
                        100
                    ]
                ]
            }
        },
        "general": {
            "rules": [
                [
                    "I MUST ALWAYS express all conditions directly and descriptively. I CANNOT use logical operators like \"or\", nor \"not\" nor \"forall\" in PDDL predicates. Instead I must represent states through explicit enumeration of facts",
                    100
                ],
                [
                    "I MUST SPECIFY EVERYTHING even if it is ambiguous, in that case select one of the valid choices and stick to it, as I CANNOT use 'or' ",
                    100
                ],
                [
                    "I can USE comments for general sections of predicates",
                    100
                ],
                [
                    "I MUST take special CARE for respecting the syntax and meaning of the domain predicates",
                    100
                ]
            ]
        }
    }
}